# Vue

## **0.那你能讲一讲MVVM吗？**

MVVM是`Model-View-ViewModel`缩写，也就是把`MVC`中的`Controller`演变成`ViewModel`。Model层代表数据模型，View代表UI组件，ViewModel是View和Model层的桥梁，数据会绑定到viewModel层并自动将数据渲染到页面中，视图变化的时候会通知viewModel层更新数据。

## **1.简单说一下Vue2.x响应式数据原理**

Vue在初始化数据时，会使用`Object.defineProperty`重新定义data中的所有属性，当页面使用对应属性时，首先会进行依赖收集(收集当前组件的`watcher`)如果属性发生变化会通知相关依赖进行更新操作(`发布订阅`)。

## **2.那你知道Vue3.x响应式数据原理吗？**

(还好我有看，这个难不倒我)

Vue3.x改用`Proxy`替代Object.defineProperty。因为Proxy可以直接监听对象和数组的变化，并且有多达13种拦截方法。并且作为新标准将受到浏览器厂商重点持续的性能优化。

> ❝
>
> Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
>
> ❞

（很简单啊）

判断当前Reflect.get的返回值是否为Object，如果是则再通过`reactive`方法做代理， 这样就实现了深度观测。

> ❝
>
> 监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？
>
> ❞

我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

面试官抬起了头。心里暗想

(这小子还行，比上两个强，应该是多多少少看过Vue3的源码了)

## **3.再说一下vue2.x中如何监测数组变化**

使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法。这样当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

（能问到这的面试官都比较注重深度，这些常规操作要记牢）

（原型链的细节可以参考我的另一篇专栏）

[一文带你彻底搞懂JavaScript原型链](https://juejin.im/post/6844903893520875527)

## **4.nextTick知道吗，实现原理是什么？**

在下次 DOM 更新循环结束之后执行延迟回调。nextTick主要使用了宏任务和微任务。根据执行环境分别尝试采用

- Promise
- MutationObserver
- setImmediate
- 如果以上都不行则采用setTimeout

定义了一个异步方法，多次调用nextTick会将方法存入队列中，通过这个异步方法清空当前队列。

（关于宏任务和微任务以及事件循环可以参考我的另两篇专栏）

(看到这你就会发现，其实问框架最终还是考验你的原生JavaScript功底)

[浏览器中JavaScript的事件循环](https://juejin.im/post/6844903881663578119)

[Node.js事件循环](https://juejin.im/post/6844904007270563848)

## **5.说一下Vue的生命周期**

`beforeCreate`是new Vue()之后触发的第一个钩子，在当前阶段data、methods、computed以及watch上的数据和方法都不能被访问。

`created`在实例创建完成后发生，当前阶段已经完成了数据观测，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。可以做一些初始数据的获取，在当前阶段无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。

`beforeMount`发生在挂载之前，在这之前template模板已导入渲染函数编译。而当前阶段虚拟Dom已经创建完成，即将开始渲染。在此时也可以对数据进行更改，不会触发updated。

`mounted`在挂载完成后发生，在当前阶段，真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。

`beforeUpdate`发生在更新之前，也就是响应式数据发生更新，虚拟dom重新渲染之前被触发，你可以在当前阶段进行更改数据，不会造成重渲染。

`updated`发生在更新完成之后，当前阶段组件Dom已完成更新。要注意的是避免在此期间更改数据，因为这可能会导致无限循环的更新。

`beforeDestroy`发生在实例销毁之前，在当前阶段实例完全可以被使用，我们可以在这时进行善后收尾工作，比如清除计时器。

`destroyed`发生在实例销毁之后，这个时候只剩下了dom空壳。组件已被拆解，数据绑定被卸除，监听被移出，子实例也统统被销毁。

(关于Vue的生命周期详解感兴趣的也请移步我的另一篇专栏)

[从源码解读Vue生命周期，让面试官对你刮目相看](https://juejin.im/post/6844903879100858382)

## **6.你的接口请求一般放在哪个生命周期中？**

接口请求一般放在`mounted`中，但需要注意的是服务端渲染时不支持mounted，需要放到`created`中。

## **7.再说一下Computed和Watch**

`Computed`本质是一个具备缓存的watcher，依赖的属性发生变化就会更新视图。 适用于计算比较消耗性能的计算场景。当表达式过于复杂时，在模板中放入过多逻辑会让模板难以维护，可以将复杂的逻辑放入计算属性中处理。

`Watch`没有缓存性，更多的是观察的作用，可以监听某些数据执行回调。当我们需要深度监听对象中的属性时，可以打开`deep：true`选项，这样便会对对象中的每一项进行监听。这样会带来性能问题，优化的话可以使用`字符串形式`监听，如果没有写到组件中，不要忘记使用`unWatch手动注销`哦。

## **8.说一下v-if和v-show的区别**

当条件不成立时，`v-if`不会渲染DOM元素，`v-show`操作的是样式(display)，切换当前DOM的显示和隐藏。

## **9.组件中的data为什么是一个函数？**

一个组件被复用多次的话，也就会创建多个实例。本质上，`这些实例用的都是同一个构造函数`。如果data是对象的话，对象属于引用类型，会影响到所有的实例。所以为了保证组件不同的实例之间data不冲突，data必须是一个函数。

组件复用时所有组件实例都会共享 `data`，如果 `data` 是对象的话，就会造成一个组件修改 `data` 以后会影响到其他所有组件，所以需要将 `data` 写成函数，每次用到就调用一次函数获得新的数据。

当我们使用 `new Vue()` 的方式的时候，无论我们将 `data` 设置为对象还是函数都是可以的，因为 `new Vue()` 的方式是生成一个根组件，该组件不会复用，也就不存在共享 `data` 的情况了。



每个组件都是vue的实例，组件共享data属性，当data的值指向同一个引用类型值的时候，改变其中一个会影响其他，所以必须要使用函数。不过当我们可以使用new Vue（）的方式的时候，无论我们将data设置为对象还是函数都是可以的，因为new Vue（）的方式是生成一个根组件，该组件不会复用，也就不存在共享data的情况了

## **10.说一下v-model的原理**

`v-model`本质就是一个语法糖，可以看成是`value + input`方法的语法糖。 可以通过model属性的`prop`和`event`属性来进行自定义。原生的v-model，会根据标签的不同生成不同的事件和属性。

## **11.Vue事件绑定原理说一下**

原生事件绑定是通过`addEventListener`绑定给真实元素的，组件事件绑定是通过Vue自定义的`$on`实现的。

> ❝
>
> 面试官：(这小子基础还可以，接下来我得上上难度了)
>
> ❞

## **12.Vue模版编译原理知道吗，能简单说一下吗？**

简单说，Vue的编译过程就是将`template`转化为`render`函数的过程。会经历以下阶段：

- 生成AST树
- 优化
- codegen

首先解析模版，生成`AST语法树`(一种用JavaScript对象的形式来描述整个模板)。 使用大量的正则表达式对模板进行解析，遇到标签、文本的时候都会执行对应的钩子进行相关处理。

Vue的数据是响应式的，但其实模板中并不是所有的数据都是响应式的。有一些数据首次渲染后就不会再变化，对应的DOM也不会变化。那么优化过程就是深度遍历AST树，按照相关条件对树节点进行标记。这些被标记的节点(静态节点)我们就可以`跳过对它们的比对`，对运行时的模板起到很大的优化作用。

编译的最后一步是`将优化后的AST树转换为可执行的代码`。

> ❝
>
> 面试官：(精神小伙啊，有点东西，难度提升，不信难不倒你)
>
> ❞

## **13.Vue2.x和Vue3.x渲染器的diff算法分别说一下**

简单来说，diff算法有以下过程

- 同级比较，再比较子节点
- 先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)
- 比较都有子节点的情况(核心diff)
- 递归比较子节点

正常Diff两个树的时间复杂度是`O(n^3)`，但实际情况下我们很少会进行`跨层级的移动DOM`，所以Vue将Diff进行了优化，从`O(n^3) -> O(n)`，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。

Vue2的核心Diff算法采用了`双端比较`的算法，同时从新旧children的两端开始进行比较，借助key值找到可复用的节点，再进行相关操作。相比React的Diff算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。

Vue3.x借鉴了 [ivi](https://github.com/localvoid/ivi)算法和 [inferno](https://github.com/infernojs/inferno)算法

在创建VNode时就确定其类型，以及在`mount/patch`的过程中采用`位运算`来判断一个VNode的类型，在这个基础之上再配合核心的Diff算法，使得性能上较Vue2.x有了提升。(实际的实现可以结合Vue3.x源码看。)

该算法中还运用了`动态规划`的思想求解最长递归子序列。

(看到这你还会发现，框架内无处不蕴藏着数据结构和算法的魅力)

> ❝
>
> 面试官：(可以可以，看来是个苗子，不过自我介绍属实有些无聊，下一题)
>
> ❞

(基操，勿6)

## **14.再说一下虚拟Dom以及key属性的作用**

由于在浏览器中操作DOM是很昂贵的。频繁的操作DOM，会产生一定的性能问题。这就是虚拟Dom的`产生原因`。

Vue2的Virtual DOM借鉴了开源库`snabbdom`的实现。

`Virtual DOM本质就是用一个原生的JS对象去描述一个DOM节点。是对真实DOM的一层抽象。`(也就是源码中的VNode类，它定义在src/core/vdom/vnode.js中。)

VirtualDOM映射到真实DOM要经历VNode的create、diff、patch等阶段。

**「key的作用是尽可能的复用 DOM 元素。」**

新旧 children 中的节点只有顺序是不同的时候，最佳的操作应该是通过移动元素的位置来达到更新的目的。

需要在新旧 children 的节点中保存映射关系，以便能够在旧 children 的节点中找到可复用的节点。key也就是children中节点的唯一标识。

## **15.keep-alive了解吗**

`keep-alive`可以实现组件缓存，当组件切换时不会对当前组件进行卸载。

常用的两个属性`include/exclude`，允许组件有条件的进行缓存。

两个生命周期`activated/deactivated`，用来得知当前组件是否处于活跃状态。

keep-alive的中还运用了`LRU(Least Recently Used)`算法。

（又是数据结构与算法，原来算法在前端也有这么多的应用）

## **16.Vue中组件生命周期调用顺序说一下**

组件的调用顺序都是`先父后子`,渲染完成的顺序是`先子后父`。

组件的销毁操作是`先父后子`，销毁完成的顺序是`先子后父`。

### 加载渲染过程

```
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount- >子mounted->父mounted
```

### 子组件更新过程

```
父beforeUpdate->子beforeUpdate->子updated->父updated
```

### 父组件更新过程

```
父 beforeUpdate -> 父 updated
```

### 销毁过程

```
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```

## **17.Vue2.x组件通信有哪些方式？**

- 父子组件通信

  父->子`props`，子->父 `$on、$emit`

  获取父子组件实例 `$parent、$children`

  `Ref` 获取实例的方式调用组件的属性或者方法

  `Provide、inject` 官方不推荐使用，但是写组件库时很常用

- 兄弟组件通信

  `Event Bus` 实现跨组件通信 `Vue.prototype.$bus = new Vue`

  `Vuex`

- 跨级组件通信

  `Vuex`

  `$attrs、$listeners`

  `Provide、inject`

## **18.SSR了解吗？**

SSR也就是服务端渲染，`也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端`。

SSR有着更好的SEO、并且首屏加载速度更快等优点。不过它也有一些缺点，比如我们的开发条件会受到限制，服务器端渲染只支持`beforeCreate`和`created`两个钩子，当我们需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境。还有就是服务器会有更大的负载需求。

## **19.你都做过哪些Vue的性能优化？**

### 编码阶段

- 尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
- v-if和v-for不能连用
- 如果需要使用v-for给每项元素绑定事件时使用事件代理
- SPA 页面采用keep-alive缓存组件
- 在更多的情况下，使用v-if替代v-show
- key保证唯一
- 使用路由懒加载、异步组件
- 防抖、节流
- 第三方模块按需导入
- 长列表滚动到可视区域动态加载
- 图片懒加载

### SEO优化

- 预渲染
- 服务端渲染SSR

### 打包优化

- 压缩代码
- Tree Shaking/Scope Hoisting
- 使用cdn加载第三方模块
- 多线程打包happypack
- splitChunks抽离公共文件
- sourceMap优化

### 用户体验

- 骨架屏
- PWA

还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。

(优化是个大工程，会涉及很多方面，这里申请另开一个专栏)

## **20.hash路由和history路由实现原理说一下**

`location.hash`的值实际就是URL中`#`后面的东西。

history实际采用了HTML5中提供的API来实现，主要有`history.pushState()`和`history.replaceState()`。



前端路由主要有两种方式

- 带有hash的前端路由，优点是兼容性高，缺点是带#不好看
- 不带hash的前端路由，优点是不带#好看，缺点是需要服务器支持

前端路由在SPA的web项目中应用很广泛。前端路由最明显的好处是页面跳转不会白屏，即页面切换快。

当再地址栏输入url点击enter键时要去服务器请求的，但是在浏览器中点击前进后退，或者利用vue-router来切换页面都是属于前端的路由，不会向服务器请求。

**hash模式：**浏览器在解析url时，#后面的路径发生变化，不会向服务器重新请求资源，只会触发hashChange事件。hash模式就是利用这一点来实现前端路由。前端的router库会捕捉#后面的参数来切换到对应的页面。服务器只会返回#之前url对应的html，具体显示哪个页面由前端路由去匹配。

**history模式：**router库通过HTML提供的history的两个API来实现，history.pushState（）和history.replaceState（）。这两个API操作浏览器历史记录，不会向服务器发起请求。前者增加一条历史记录，后者直接替换掉当前的url。



## 21.vue 双向绑定底层实现原理

vue.js 采用数据劫持的方式，结合发布者-订阅者模式，通过Object.defineProperty()来劫持各个属性的setter，getter以监听属性的变动，在数据变动时发布消息给订阅者，触发相应的监听回调：





**主要的**

# 原型和原型链（new运算符以及instanceof的原理）

#### 原型和原型链

原型又叫原型属性，属性中存储的是（原型对象），原型又分为显示原型和隐式原型，

所有的函数，都有一个prototype属性（显式原型）属性值也是一个普通对象

所有的实例对象，都有一个`__proto__`属性（隐式原型），属性值也是一个普通的对象

且实例对象的隐式原型指向其构造函数的显式原型

原型链就是用来描述通过隐式原型对象查找属性的过程，因为对象的隐式原型指向其对应构造函数的显式原型，当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么就会去它的_proto_(即它的构造函数的prototype)中寻找，这样通过__proto__属性查找就形成了一个链的结构---->原型链。

原型链的链头是object.prototype，它的`__proto__`值为null

#### new运算符的流程

流程：

1. 创建对象，开辟内存空间（堆）；
2. 设置原型链
3. this指向该内存。
4. 执行函数代码
5. 将创建对象实例返回。

创建一个空对象，并且this变量引用该对象，同时继承了该函数的原型（实例对象通过__proto__属性指向原型对象；obj.__proto__ = Base.prototype;） 2、属性和方法被加入到 this 引用的对象中。

#### instanceof的原理（instanceof 确定原型和实例之间的关系）

用来判断某个构造函数的prototype属性是否存在另外一个要检测对象的原型链上



# 闭包

闭包就是能够读取其他函数内部变量的函数（当嵌套的内部函数引用了其外部函数的变量（函数）时，就形成了闭包。）

闭包的产生：嵌套的外部函数被调用的时候，也就是内部函数被定义的时候就产生了。

闭包的死亡：当内部函数没有被引用的时候，函数就会成为垃圾对象，并且闭包随之消失

闭包的用处：1可以读取函数内部的变量，2就是让这些变量的值始终保持在内存中，延长局部变量的生命周期

缺点：局部变量的生命周期得以延长，而未及时释放其所占的内存，造成内存泄漏

闭包的应用场景：react中使用受控组件收集表单数据时封装的高阶函数时



# js的事件轮询机制

js是单线程，也就是说js在同一时间只能做一件事，所以就意味着，所有任务需要排队，这样就可能会阻塞运行，于是在js中就使用了异步，添加了一个任务队列。将一些需要等待的事件（异步代码）放到任务队列里。

所有任务都在主线程上执行，形成一个执行栈。

执行机制是 首先判断 `js` 代码是同步还是异步，同步放入主线程执行栈执行，异步先挂起等待（管理模块），事件发生时，再放到任务队列中去。如果执行栈中的所有同步任务执行完毕，js就会读取消息队列中的异步任务，如果有可以执行的任务就把他放入执行栈中并开始执行。



# 微任务宏任务

```text
js 是单线程执行的，js中的任务按顺序一个一个的执行，但是一个任务耗时太长；
那么后面的任务就需要等待，为了解决这种情况，将任务分为了同步任务和异步任务；
而异步任务又可以分为微任务和宏任务。
```

- 宏任务：

setTimeout

setInterval

js主代码

setImmediate(Node)

requestAnimationFrame(浏览器)

- 微任务：

process.nextTick

Promise的then，catch方法

执行：

在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被对应的宏任务队列或者微任务队列中去。并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回调加入当前执行栈；如果存在，则会依次执行微任务队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈…如此反复，进入循环。

我们只需记住当当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。

在当前的微任务没有执行完成时，是不会执行下一个宏任务的。



**微任务中如果新添加了微任务，则把新添加的微任务放到下一个微任务队列执行，还是会排在主线程上创建出的宏任务之前执行**







# promise

Promise对象是一个异步编程的解决方案，可以将异步操作以同步的流程表达出来, 避免了层层嵌套的回调函数(俗称'回调地狱')

Promise是一个构造函数，我们可以通过该构造函数来生成Promise的实例。构造函数自己身上有all、race这些方法，原型上有then、catch等这些方法

`Promise`对象有三种状态：代表异步执行的状态（状态不受外界影响）,对象的状态只能改变一次

pending（等待）、resolved（成功）、rejected（失败）。

Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。

resolve函数的作用是，将Promise对象的状态从"未完成"变成"成功"。（即从pending变为resolved）。在异步操作成功的时候调用，并将异步操作结果作为参数传递出去；

reject函数的作用是，将promise对象的状态从"未完成"变成"失败"（即从pending变为rejected）。在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。

Promise实例生成后，可以用then方法分别指定resolve状态和rejected状态的回调函数。

then方法可以接受两个回调函数作为参数，

第一个回调函数是promise对象的状态变为resolved的时候调用，

第二个回调函数是promise对象的状态变为rejected时调用。

其中第二个函数是可选的，不一定需要提供。

这两个函数都接受Promise对象传出的值作为参数。

then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）因此可以采用链式写法，即then方法后面再调用另一个then方法。

catch方法用于指定发生错误时的回调函数，如果异步操作抛出错误，状态就会变为rejected，就会调用catch方法指定的回调函数

then / catch 方法返回值是一个新的promise对象,新promise对象默认是成功状态,当then方法或catch方法中的函数 return返回值是一个promise对象的时候,那么then / catch 方法返回值的promise就是这个return的promise对象

Promise.all([promise1, ...]) 传入n个promise对象，只有n个promise对象的状态都成功，才成功，只要有一个失败，就失败，也是返回一个promise，传递的值为数组，数组里的值为n个promise对象resolve的参数

Promise.race([promise1, ...])返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态

# async和await

async函数其实就是Genarator函数（生成器函数）的语法糖而已，真正意义上去解决异步回调的问题，同步流程表达异步的操作

async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成

async 函数会返回一个 Promise 对象,返回的promise对象的结果由async函数执行的返回值决定

`await` 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西， await右侧的表达式一般为promise对象, 但也可以是其它的值， 如果表达式是promise对象, await返回的是promise成功的值，如果表达式是失败的promise（可通过try...catch捕获），那么此时将直接退出async函数，async函数返回失败的promise，如果表达式是其它值, 直接将此值作为await的返回值。

注意 await必须写在async函数中, 但async函数中可以没有await





# this的指向

所有的this关键字，在函数运行时，才能确定它的指向

函数是否在new中调用，如果是的话，this绑定的是新创建的对象

函数是否通过call、apply（显示绑定）调用，如果是，则this绑定的是执行的对象

函数是否在某个上下文对象中调用(隐式绑定)，如果有，则this绑定在这个上下文对象上

如果以上都不是 则默认绑定 执行window





# call和apply和Bind

是function自带的三个方法，这三个函数的存在意义是**改变函数执行时的上下文**，再具体一点就是**改变函数运行时的this指向**。

区别：

call和apply改变了函数的this上下文后便执行该函数,而bind则是返回改变了上下文后的一个函数(要手动调用)。

call，bind和apply的第一个参数都是要改变上下文的对象，而call和bind从第二个参数开始以参数列表的形式展现，apply则是把参数放在一个数组里面作为它的第二个参数。

应用场景：

​		call主要用于继承

　　 apply 经常跟数组有关系，比如借助Math内置对象实现求数组最大最小值问题

　　bind 不调用函数，又想改变函数内部this指向 比如 定时器之类的问题



# 执行上下文

当 `JS` 引擎解析到可执行代码片段（通常是函数调用阶段）的时候，就会先做一些执行前的准备工作，这个 **“准备工作”**，就叫做 **"执行上下文(execution context 简称 `EC`)"** 或者也可以叫做**执行环境**。

执行上下文分为（全局代码）**全局执行上下文**和（函数代码）**函数执行上下文**

**全局执行上下文**——这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，
它在整个 `javascript` 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 `window`），并且将 `this` 值绑定到这个全局对象上。

**函数执行上下文**——每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的）

每个执行上下文 都有三个重要属性：1.变量对象（VO） 2.作用域链 3.this

每个执行环境文都有一个表示变量的对象——**变量对象**，全局上下文的变量对象就是window对象，**函数执行上下文中的变量对象内部定义的属性，是不能被直接访问的**，只有当函数被调用时，变量对象（VO）被激活为活动对象（AO）时，我们才能访问到其中的属性和方法。

变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明（在函数被调用时且在具体的函数代码运行之前，JS 引擎会用当前函数的**参数列表**（`arguments`）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 **变量** 和 **函数** 将作为属性添加到这个变量对象上。）



### 变量提升

__在执行环境的第一步（创建阶段时），会将带var的变量声明和函数的声明，放到所在的作用域顶端中，在执行阶段时，它的相关逻辑还是放在原来的位置进行赋值和其他的逻辑处理。__





# 作用域和作用域链

#### 作用域

作用域是指代码中定义变量的区域，限定一个变量可访问的范围的，作用域的本质是对象,在书写代码的时候（定义函数的时候），作用域就已经确定好了。作用当然是隔离变量啦，作用域分为全局作用域，局部作用域(函数作用域)，es6新增块级作用域。

最外层的是全局作用域，任何地方都可以访问得到。在最外层作用域下使用 `var` 关键字会定义全局变量，也就是说会挂载在 `window` 对象上

函数作用域是指属于这个函数的全部变量 都可以在整个函数的范围内使用及复用，函数作用域内的变量或者内部函数，对外都是封闭的，从外层的作用域无法直接访问函数内部的作用域，否则会报引用错误异常。解决方法：`闭包`。

块级作用域，使用{}扩起来的区域叫做块级作用域，作用域是通过声明变量的方式确定的，使用let和const声明变量 都是以代码块确定作用域，作用防止全局变量污染。可以任意嵌套，块级作用域的诞生使立即执行函数表达式不再必要

#### 作用域链

（变量对象是与执行上下文相关的数据作用域，储存了在上下文中定义的变量和函数声明）

当代码在一个环境中执行时,会创建变量对象的一个作用域链( scope chain),作用域链的用途,是保证对执行环境有权访问的所有变量和函数的有序访问

作用域的前端是当前执行环境的作用域，后端是全局作用域，访问查询是从前端到后端





**总结**：**作用域** 规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做 **作用域链**。









# 模块化和组件化（是什么，区别特点）

模块是什么？组件又是什么

模块一般指的是 Javascript 模块，理解为向外提供特定功能的js程序，一般就是一个js文件，模块化侧重的功能的封装，主要是针对Javascript代码，隔离、组织javascript代码，将它封装成一个个具有特定功能的的模块

组件可以简单理解为具有特定功能的HTML、css、js代码的集合，也可以理解为页面的某一块，组件化更多关注的是UI部分。组件化将页面视为一个容器，可以根据需要把它放在页面的任意部位，也可以和其他组件一起形成新的组件。



特点：

**开发和调试效率高**（随着功能越来越多，代码结构会越发复杂）

**可维护性强**

**独立性强，易于复用**

**解决命名冲突、提供复用性、提高代码可维护性**







# 移动端的适配

## rem适配

**rem**是相对长度单位，rem方案中的样式设计为相对于**根元素**`font-size`计算值的倍数。根据 **屏幕宽度** 设置`html`标签的`font-size`，在布局时使用 **rem** 单位布局，达到自适应的目的，是 **弹性布局** 的一种实现方式。

引入 flexible.js 来实现以上，vue和react脚手架借助插件`postcss-pxtorem`自动帮我们把px转为rem。

## viewport(vw)移动端适配

我们可以借助<meta>元素的 viewport 来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。

然后引入与视口有关的新的单位vw和vh，vw表示相对于视口的宽度，vh表示相对于视口高度

通过postcss-px-to-viewport插件进行单位转换比较方便



# AJAX异步请求以及跨域解决

AJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。

优点：可以无需刷新页面而与服务器端进行通信。允许你根据用户事件来更新部分页面内容

缺点：没有浏览历史，不能回退，存在跨域问题

步骤

1.创建xhr对象

2.open规定请求方式和地址（接口文档有，别乱写，请求方式地址和服务器的一致则返回内容）

3.send发送请求

4.注册onload事件,拿到服务器给你的结果

跨域：

浏览器在Ajax调接口时，请求了一个` 不同源`的 地址 就回出现跨域问题

同源就是两个网址中:协议，地址，端口这三个 都一样

**跨域解决方案：**

1 cors(白名单)，后端设置白名单允许你的浏览器地址下的ajax 代码可以请求这个不同源的接口

原理：服务器设置一个允许的`header`浏览器接收到这个响应之后，检查是否有这个`header`

2 JSONP，JSONP不是Ajax请求，因为他完全没有使用XMLHttpRequest对象，是一个非官方的跨域解决方案，只支持get

原理：有一些标签天生具有跨域的能力，利用标签的跨域能力来发送请求



3.proxy服务代理，服务器之间没有跨域的概念，通过代理服务器去访问要跨域访问的目标服务器得到数据，代理服务器再把数据返回给我



# axios

 前端最流行的ajax请求库

## 1.1. axios特点

1. 基于xhr + promise的异步ajax请求库

2. 浏览器端/node端都可以使用

3. 支持请求／响应拦截器

4. 支持请求取消

5. 请求/响应数据转换

6. 批量发送多个请求

get params传参 post  data传参









# 对前端路由的理解？前后端路由的区别？

　**前端路由就是把不同路由对应不同的内容或页面的任务交给前端来做，之前是通过服务端根据 url 的不同返回不同的页面实现的；**

后端路由每跳转到不同的URL，都是重新访问服务端，然后服务端返回页面，页面也可以是服务端获取数据，然后和模板组合，返回HTML，也可以是直接返回模板HTML，然后由前端JS再去请求数据，使用前端模板和数据进行组合，生成想要的HTML。



```
前端路由
页面跳转的url由前端匹配，url改变时不会重新加载页面，也就是不会像服务器重新请求资源。
		1)由js库进行解析(Vue-Router,React-Router-DOM)
		2)前端路由不会请求新的页面,不走网络传输层
		3)返回的应该是组件
```

	后端路由
		1)由服务器解析
		2)由前端发送请求触发
		3)返回的一般是数据


# webpack以及打包过程常用loader

Webpack是一个模块打包器(bundler)。（构建工具）

模块的引入解决了文件之间依赖引用的问题，而打包则解决了文件过多的问题。提供模块化的开发方式和编译打包功能就是webpack的核心，其他很多功能都围绕它们展开。

五个核心概念：

* Entry：入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。
* Output：output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件
* Loader：loader 让 webpack 能够去处理那些非 JavaScript 文件（文件加载器，能够加载资源文件，并对这些文件进行一些处理）
* Plugins：插件则可以用于执行范围更广的任务。例如：打包优化、压缩，
* Mode：模式，有生产模式 production 和开发模式 development 



**Webpack 本身只能加载 JS/JSON 模块，如果要加载其他类型的文件(模块)，就需要使用对应的loader 进行转换/加载**

**webpack和gulp的区别**

webpack是一种模块化打包工具，主要用于模块化方案，预编译模块的方案；gulp是工具链、构建工具，可以配合各种插件做js压缩，css压缩，less编译 替代手工实现自动化工作。

Grunt/Gulp更多的是一种工作流；提供集成所有服务的一站式平台； gulp可以用来优化前端工作流程。



**loader和plugin的区别**

对于loader，它是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss转换为A.css，单纯的文件转换过程

plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务



**常用的loader：**







# cookie session和webstorage(localstorage和sessionstorage)

cookie和webstorage是前端本地存储，session是服务器存储



Web Storage又分为两种： sessionStorage 和localStorage ，即这两个是Storage的一个实例

sessionStorage将数据保存在session中，浏览器关闭也就没了

localStorage始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据(除非清除浏览器缓存)

cookie只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭

Web Storage和cookie都是保存在浏览器客户端，而session是保存在服务器（更安全）

cookie保存数据不能超过4K，且每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。

Web Storage不参与和服务器的通信，虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大

session会在一定时间内保存在服务器上，当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie

作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的







# 防抖和节流

防抖和节流都是为了解决**短时间内大量触发某函数**而导致的**性能问题，**都是为了节约函数的性能（让函数调用次数更少）

防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。（,防抖将多次执行变为**最后一次**执行）

应用场景：window的resize、scroll事件，不断地调整浏览器的窗口大小、或者滚动时会触发对应事件，防抖让其只触发一次；

一般可以使用在用户输入停止一段时间过后再去获取数据，而不是每次输入都去获取

节流：指定时间间隔内只会执行一次任务（**节流是将多次执行变成每隔一段时间执行**）

应用场景：用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次



# 从输入 url 到解析出来的全过程（浏览器解析 URL）

**1.DNS 查询/解析**

​    输入的是域名，需要DNS解析

​    DNS解析是把域名解析为IP地址（4个缓存 1个递归查询）

​    \- 浏览器的DNS缓存

​    \- 计算机DNS缓存

​    \- 路由器DNS缓存

​    \- 运营商缓存

​    \- a.com  b.a.com   c.b.a.com

  **2.tcp三次握手**

​    目的：确认让客户端和服务端互相知道，对方有接受和发送的能力

​    为什么要第三次握手：因为第三次握手以后，服务端才能知道客户端有接受信息的能力

​    \- 客户端发送给服务端，告诉服务端我要准备发请求了

​    \- 服务端发送给客户端，我同意你可以发请求

​    \- 客户端发送给服务端，好的收到你的确认信息

   Connection: keep-alive：长连接 代表的就是tcp的连接

  **3.发送请求**

​    客户端发送请求报文给服务端

  **4.返回响应**

​    服务端处理完客户端的请求，并向客户端返回响应报文包

  **5.渲染页面**

​    \- 根据html生成DOM tree

​    \- 根据css生成CSSOM tree

​    \- 结合CSSOM和DOM 生成 render tree(渲染树)

​    \- 分层（根据层叠上下文分层）

​    \- 生成图层绘制指令

​    \- 栅格化 把图层分为图块

​    \- 合成与显示 最终绘制过程

  **6.TCP四次挥手**

​    \- 客户端发送给服务器端：请求报文发送完毕

​    \- 服务器端发送给客户端：请求报文已经接受完毕，可以等待断开

​    \- 服务器端发送给客户端：响应报文已经发送完毕

​    \- 客户端发送给服务器端：响应报文已经接受完毕 可以断开连接

**总结**

1. 用户输入 URL 地址。
2. 对 URL 地址进行 DNS 域名解析。
3. 建立 TCP 连接（三次握手）。
4. 浏览器发起 HTTP 请求报文。
5. 服务器返回 HTTP 响应报文。
6. 关闭 TCP 连接（四次挥手）。
7. 浏览器解析文档资源并渲染页面。







# 浏览器渲染流程

1. 浏览器开始解析目标HTML文件，执行流的顺序为自上而下。
2. HTML解析器将HTML结构转换为基础的DOM(文档对象模型)，构建DOM树完成后，触发DomContendLoaded事件。
3. CSS解析器将CSS解析为CSSOM(层叠样式表对象模型)，一棵仅含有样式信息的树。
4. CSSOM和DOM开始合并构成渲染树（render Tree），每个节点开始包含具体的样式信息。浏览器就是根据render tree来绘制页面的
5. 计算渲染树中个各个节点的位置信息，即布局阶段。
6. 将布局后的渲染树显示到界面上。









# 重绘与回流

**重绘(repaint)**：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此**损耗较少**。

常见的**重绘**操作有：

1. 改变元素颜色
2. 改变元素背景色
3. more ……

**回流(reflow)**：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。

常见的**回流**操作有：

1. 页面初次渲染
2. 浏览器窗口大小改变
3. 元素尺寸/位置/内容发生改变
4. 元素字体大小变化
5. 添加或者删除可见的 DOM 元素
6. 激活 CSS 伪类（:hover……）



**重点**：**回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高。**

当render tree中的一部分或者是全部，因为元素的尺寸、布局、隐藏等等改变引起页面的重新渲染，这个过程称作为重排，完成重排以后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘。













# DOMContentLoaded事件和window.onload的区别

window.onload页面的全部资源加载完才会执行，包括样式表，图片，视频等

DOMContentLoaded DOM渲染完即可执行，不包括样式表，图片。





# 事件委托

事件委托也叫做事件代理，元素的事件委托给它的父元素或者外层元素。
**通俗点说：就是通过父元素给子元素绑定事件。**

它是如何实现的呢？点击子元素，冒泡到父元素上，触发父元素的点击事件。
事件委托的原理，是事件冒泡。

优点：减少绑定事件， 减少内存消耗，节约效率

​			动态绑定事件  给未来元素绑定事件

缺点：事件委托基于冒泡，对于不冒泡的事件不支持。（resize,load,blur,focus,mouseenter,mouseleave）

​			层级过多，冒泡过程中，可能会被某层阻止掉



# flex布局

- 开启：display:flex;(safari兼容)-webkit-flex
- 开启flex的元素自身不会受影响，子元素的浮动会失效，vertical-align也会失效
- flex盒子只能影响子元素，不会影响子元素以下的元素，如要的话可以给子元素再设。
- 开启后父级叫伸缩容器，子元素叫伸缩项目
- 默认情况下从左往右排，横向主轴，竖向叫侧轴（交叉轴），开始是主轴开始，结束是主轴结束。

**开启后特性：**

项目沿着主轴从左至右依次排列（可以改变主轴方向，从而改变元素的排列方向）

项目没有设置高度的话则高度撑满容器

当项目宽度超出总宽度，并不会超出或换行，而是按比例压缩项目。

不会影响当前元素的浮动和定位。

```js
**flex-direction:主轴布局方向**（按方向元素依次排）

​		row:默认 主轴方向从左至右。

​		row-reverse:主轴方向从右至左。

​		column:  主轴方向从上至下，侧轴主轴交换位置（元素未设宽的话，侧轴充满）

​		column-reverse:主轴方向从下至上，侧轴主轴交换位置，侧轴依然从左往右。

**justify-content：主轴富裕空间管理**

​		flex-start：项目排列在主轴开始位置

​		flex-end:项目排列在主轴结束位置（和反转主轴不一样 ，这个是整体移动到结束位置）

​		center：项目居中

​		space-between：项目包含富裕空间

​		space-around：富裕空间包含项目

​		space-evenly：富裕空间包含项目，所有项目左右富裕空间一致。

**align-items：侧轴富裕空间管理**

​		flex-start：元素在侧轴的开始位置

​		flex-end：元素在侧轴的结束位置

​        center：元素在侧轴居中

​		baseline：元素以基线对齐

​		stretch：默认，项目撑满侧轴（如果设置了宽高，以宽高为优先）



**flex-grow：富裕空间分配（设置给项目的）后接数字**

  
**flex-shrink：项目的收缩率  设置给项目**

默认为1均摊，为0的话就不均摊，溢出就溢出


**flex-wrap:项目换行（超出才换）**

​		nowrap:不换行

​		wrap:换行（无论主轴方向如何，超出容器的宽度或高度都会换行）

​		wrap-reverse:换行并且反转侧轴。（从左至右变从右到左排；从上至下变从下至上排）

超出换行后每行都有自己独立的主轴侧轴。操作都在自己的轴里进行。



**align-content：控制项目换行后，整体的侧轴对齐方式。(必须有换行才能生效)**

意思是换行元素跳出自己独立的轴空间，整体打包 相对于整个容器的侧轴的对齐方式。

​		flex-end:结束位置

​		flex-start:开始位置

​		center：居中位置

​		space-between：项目包含侧轴富裕空间

​		space-around：侧轴富裕空间包含项目

​		space-evenly：侧轴富裕空间包含项目，富裕空间一致。



**align-self：项目自身侧轴的富裕空间（设置给项目）不需要换行也可以**

每一个项目控制自身的侧轴

align-self: flex-start;

align-self: flex-end;

align-self: center;

​		

**order排序：设置给项目  后接数字**

正order > 无order（order为0）> 负order

order越大越往后排，越小越往前排，可以用来改变顺序。



**flex-basis: 0 子元素的基准值 设置给项目**  

定义了在分配剩余空间之前，项目所占据主轴的位置多少。

一般和flex-grow 搭配使用，使项目等高等宽（等高等宽视主轴方向而定）






**flex属性合写**  设置给项目

flex: flex-grow  flex-shrink  flex-basis的合写

默认值： 1   1   auto



**flex-flow属性合写**  设给容器

flex-flow:  flex-wrap    flex-direction
```









# H5和C3

**H5有哪些新特性？**

1.画布(Canvas) API

2.地理(Geolocation) API

3.音频、视频API(audio,video)

4.localStorage和sessionStorage

5.webworker, websocket

6.header,nav,footer,aside,article,section 语义化标签

**C3的新特性？**

1. 颜色: 新增RGBA , HSLA模式
2. 文字阴影(text-shadow)
3. 边框: 圆角(border-radius) 边框阴影 : box-shadow
4. 盒子模型: box-sizing
5. 背景:background-size background-origin background-clip
6. 渐变: linear-gradient , radial-gradient
7. 过渡 : transition 可实现动画
8. 自定义动画 animate @keyfrom
9. 弹性布局flex



# nodeJS模块化和nodeJs的事件轮询机制

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。node.js不是一种独立语言，是一个可以让js在服务器端运行的平台。

简单来讲，就是一个使用JS写服务器的代码环境。

## 模块化

在nodejs中，应用由模块组成，nodejs中采用commonJS模块规范。（AMD也是一种规范）

1. 一个js文件就是一个模块
2. 每个模块都是一个独立的作用域，在这个而文件中定义的变量、函数、对象都是私有的，对其他文件不可见。（不会污染全局作用域。）







### module.exports与exports

- `exports` 是 `module.exports` 的引用
- 注意：给 `module.exports` 赋值会切断与 `exports` 之间的联系 
- 给`exports`赋值也会切断联系









# Es6的内容

块级作用域

let const

解构赋值

扩展运算符

箭头函数

属性名表达式

Symbol(新增加数据类型)

新增数据结构   Set(去重)，Map

class类与继承





# TCP 三次握手与四次挥手

 目的：确认让客户端和服务端互相知道，对方有接受和发送的能力

​    为什么要第三次握手：因为第三次握手以后，服务端才能知道客户端有接受信息的能力

​    \- 客户端发送给服务端，告诉服务端我要准备发请求了

​    \- 服务端发送给客户端，我同意你可以发请求

​    \- 客户端发送给服务端，好的收到你的确认信息





 \- 客户端发送给服务器端：请求报文发送完毕

​    \- 服务器端发送给客户端：请求报文已经接受完毕，可以等待断开

​    \- 服务器端发送给客户端：响应报文已经发送完毕

​    \- 客户端发送给服务器端：响应报文已经接受完毕 可以断开连接



### 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

TCP 是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。



# es6的类和类的继承(class)

ES6 的类，完全可以看作构造函数的另一种写法，就是一个语法糖；本质还是一个function

ES6类上的所有方法（除了用static定义的）都定义在类的prototype属性上面(原型对象上面)

使用static定义的属于属性或者方法叫静态属性和静态方法，只能通过类名调用，不会被子类继承

`constructor`方法是类的默认方法，通过`new`命令生成对象实例时，自动调用该方法。一个类必须有`constructor`方法，如果没有显式定义该方法，系统会隐式的添加一个空的constructor，方法中书写的是实例对象的私有化属性

Class 可以通过`extends`关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多

ES6中继承的子类中，如果使用构造函数constructor()那么就必须使用super()方法初始化，这样下面才可以调用this关键字，super()只能用在子类的构造函数之中，用在其他地方就会报错,这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。

如果不调用super方法，子类就得不到this对象。





# 对象的继承方式

### 借用构造函数继承

**在子类型构造函数中通用super()调用父类型构造函数**（只能继承实例对象私有的方法属性）

```
子类型
 Animal.call(this, 5);  //让Animal中的this指向本this（也就是cat1）
```



### 原型链继承

**子类型的原型为父类型的一个实例对象**

```
Cat.prototype = new Animal(); //重新设置Cat的原型对象，让Cat的原型对象为拥有Animal构造函数原型对象的对象、
```



### 混合继承（原型链+借用构造函数的组合继承）

利用原型链实现对父类型对象的方法继承

利用super()借用父类型构建函数初始化相同属性

```
Animal.call(this, 3); //只能继承私有的属性和方法
 //共有的属性和方法在prototype上，需要用prototype来实现继承
Cat.prototype = new Animal();
Cat.prototype.constructor = Cat;
```



# 深拷贝和浅拷贝

基本数据类型：拷贝后会生成一份新的数据,修改拷贝以后的数据不会影响原数据

引用数据类型：拷贝后不会生成新的数据,而是拷贝的是引用,修改拷贝以后的数据可能会影响原来的数据

浅拷贝：拷贝引用,只拷贝一层生成新数据，修改拷贝以后的内部引用数据类型会影响原数据

深拷贝(深度克隆)

     - 特点: 拷贝的时候生成新数据,修改拷贝以后的数据不会影响原数据

**1.浅拷贝： 将原对象或原数组的引用直接赋给新对象，新数组，新对象／数组只是原对象的一个引用**

**2.深拷贝： 创建一个新的对象和数组，将原对象的各项属性的“值”（数组的所有元素）拷贝过来是“值”而不是“引用”**

**深拷贝实现：**

1.JSON.parse(JSON.stringify(obj1))

2.插件lodash.cloneDeep实现深拷贝

```
import _ from 'lodash'
var obj2 = _.cloneDeep(obj);
```

3.自己手写实现（递归实现）

```
function checkType(target) {
  return Object.prototype.toString.call(target).slice(8, -1);
}

// 深度克隆
function deepClone(target) {
  // 检测数据类型
  const type = checkType(target);

  let result = null;

  if (type === "Object") {
    result = {};
  } else if (type === "Array") {
    result = [];
  } else {
    // 其他数据类型就返回
    return target;
  }

  for (const key in target) {
    const value = target[key];
    result[key] = deepClone(value);
  }

  return result;
}

```



**浅拷贝实现：**

ES6 object.assign()

```
var newObj = object.assign(obj)
```

ES6 展开运算符

```
var newObj = {...obj}
```

使用for…in循环拷贝

```js
function clone(obj) {
    if(!obj) return
    var newObj = obj.isArray(obj)? []:{}//或者使用instanceof判断obj是否是Array
    for(const key in obj) {
        newObj[key] = obj[key]
    }
    return newObj
}
```



# 块级元素水平垂直居中（已知元素宽高，未知元素宽高）

```js
已知元素宽高
position: absolute;
    在定位的时候，直接使用calc方法 计算left的百分之50 减去自身的宽度
    一次性定位结束*/
left:calc(50% - 150px);元素自身宽度一半
top:calc(50% - 100px);元素自身高度一半

position: absolute;
left:50%;
top:50%;
margin-left: -150px;
margin-top: -100px;

未知元素宽高
position: absolute;
left:50%;
top:50%;
/*transform是变形的属性，里边包含一个位移的值， 百分比是相对自身宽度的*/
transform: translate(-50%,-50%);

position: absolute;
left: 0;
top: 0;
bottom: 0;
right: 0;
margin: auto;

父元素设置
display:flex;
align-items:center;
justify-content:center;
```



# DOM2和DOM0绑定事件的区别

**DOM0:使用DOM对象的事件属性进行赋值,DOM0绑定事件事件流是冒泡，DOM0对同一个元素绑定同一个事件多次，会进行覆盖**

**DOM2:同一元素可以绑定同一事件多次，不会覆盖会依次执行，可以控制事件流是冒泡还是捕获**



**按顺序来：**

浮动，定位 bfc



自执行函数（IIFE）

对象的三种创建方式



### 虚拟dom的理解？为什么虚拟dom会提高性能？

虚拟dom相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的dom操作，从而提高性能，具体实现思路：使用js中对象结构来生成dom结构树，然后在更新时在生成一个dom结构树，新旧dom结构树进行差异对比，最后差异部分进行替换，应用到dom上







# VUE

## vue是什么？

Vue是一个渐进式的框架，什么是渐进式的呢？

渐进式的解释: 所谓的渐进式,就是Vue本身实现的功能是有限的,但是相关的插件有很多,只要安装或者引入使用即可完成更多的功能



## Vue的优点/特点

 *      1)	借鉴angular的模板和数据绑定技术
 *      2)	借鉴react的组件化和虚拟DOM技术

1)     遵循MVVM模式

2)     编码简洁, 体积小, 运行效率高, 适合移动/PC端开发

3)     它本身只关注UI, 可以轻松引入vue插件或其它第三库开发项目

## 路由router（跳转以及传参）

路由:指的是一种映射关系,地址和组件的关系

组件:具有特定功能效果的集合(html+css+js)

组件又分为普通的组件和路由组件

路由组件:普通组件通过注册和某个地址发生了关系,此时该组件就是路由组件

**要想使用路由,必须要先注册路由,然后通过声明式路由或者编程式路由实现单页面应用**

**路由跳转：**

- 声明式路由:路由链接(地址)和路由视图(展示某个组件内容的)组成（router-link和router-view）

- **<router-view> 是用来渲染通过路由映射过来的组件，当路径更改时， 中的内容也会发生更改，可以对应多个组件**

- 编程式路由:通过js代码的方式来实现地址和组件的效果展示

- **一旦路由注册成功后,每个组件对象中都会有两个对象:**

- $route:路由信息对象,内部有path属性用来获取当前路由跳转的地址,params对象和query对象

- $router:路由器对象,可以调用push/replace/back方法,进行编程式路由


**路由传参：**

params，如果是多个就写成params对象的方式，对象方式只能用name引入路由（路由注册时需要加name属性）

query，如果是多个就写成query对象的方式，对象方式可以是path也可以是name引入路由

meta，props都是在路由注册的时候传

区别：

​	params是路由的一部分,必须要在路由后面添加参数名。query是拼接在url后面的参数，没有也没关系。

​	二者还有点区别，直白的来说query相当于get请求，页面跳转的时候，可以在地址栏看到请求参数，而params相当于post请求，参数不会再地址栏中显示。

## vuex

Vuex:集中式的管理状态数据,是一种管理状态数据的模式,也是一种工具,也是一个对象（**Vuex是一种状态管理模式，存在的目的是共享可复用的组件状态。**）

Vuex的状态管理模式:通过actions来改变数据的状态,从而使界面发生变化

**什么时候需要用vuex？**

跨组件共享数据、跨页面共享数据（各个组件都能拿到数据，各组件通信（传递数据））

**vuex有五个核心概念**

**state：包含了多个状态数据的对象(data里的数据)**

**mutations:包含了多个直接修改状态数据的方法的对象，（mutation接受 state 作为第一个参数）**

- ​	mutations对象中的每个方法都可以叫mutation，
- ​	都是同步的代码

**actions:包含了多个间接修改状态数据的方法的对象**

- ​	actions对象中的每个方法都可以叫action
- ​	同步或者异步的代码
- ​	Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 `context.commit` 提交一个mutation
- 可以将commit解构赋值出来

**getters:包含了多个状态数据的计算属性的GET方法的对象（Getter 接受 state 作为其第一个参数）**

**modules：当项目庞大，状态非常多时，可以采用模块化管理模式。Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 `state、mutation、action、getter`、甚至是嵌套子模块——从上至下进行同样方式的分割**。

```
曾经获取数据：
this.$store.state.xxx 或者 ...mapState(['xxx'])

使用modules后获取数据
this.$store.state.home.xxx(home为模块名)
...mapState({
	xxx:state=>state.home.xxx
})
只有state中的数据访问不一样，其他和之前一样
```



**辅助函数**

通过辅助函数mapState、mapActions、mapMutations，把vuex.store中的属性映射到vue实例身上，这样在vue实例中就能访问vuex.store中的属性了，对于操作vuex.store就很方便了。

**mapState:把state属性映射到computed身上**

**mapAcions：把actions里面的方法映射到methods中**

**mapMutations：把mutations里面的方法映射到methods中**

**mapGetters:把getters属性映射到computed身上**



## 组件通信（以及高级通信方式）

 **Vue中组件通信的方式(普通的):**

- props: 父子组件之间通信,可以传递动态的属性或者是回调函数
- 自定义事件:父子组件之间通信,事件（子组件emit手动分发）
- 事件总线:任意组件之间进行通信,本质:原型（在mian.js中
  Vue.prototype.bus = new Vue()）
- PubSub消息订阅:不属于Vue,单独的一个插件(React中同样可以使用),任意组件通信
- 插槽(普通插槽:没有名字,具名插槽:有名字,作用域插槽):父子组件通信
- vuex:任意组件通信





**Vue中组件通信的方式(高级的):**

1. 自定义事件和原生事件
   原生事件和自定义事件,主要是针对组件而言的,组件中可以使用原生事件,也可以使用自定义事件
   原生事件:系统自带的,事件绑定了回调函数后,事件一旦触发,对应的回调函数中的代码就会自动的执行
   自定义事件:自己定义的事件
   组件中原生事件:使用了系统自带的事件,并且使用了.native进行修饰
   组件中自定义事件:自己定义的或者使用了系统自带的事件,但是没有使用.native进行修饰
   组件中的原生事件,最终事件给了子级组件中的最外层的html标签了(使用了事件委托的方式实现的)
   组件中的自定义事件:是子级组件内部手动的分发父级组件传递过来的自定义事件,才能够正常的使用

```js
组件中使用了自定义事件,但是又使用了.native进行了修饰,此时到底是原生事件还是自定义事件?
  自定义事件

1. 组件中传递自定义事件的方式:可以实现父子组件,子父组件进行通信
2. v-model指令实现组件通信(本质:value属性和input事件)
  当一个组件中使用了v-model指令,也就意味着,向这个子级组件传递了value属性和input事件,子级组件中可以接收并使用value属性的数据,同时也可以分发input自定义事件,最终可以实现父子,子父组件的通信

3. .sync修饰符实现父子组件通信
  .sync的本质:向子级组件内部动态传递数据,子级内部分发父级组件传递的自定义的update事件,从而实现数据更新,其实是:父子组件通信
4. $attrs和$listeners实现组件通信
  $attrs: 父级组件向子级组件中传递的所有的属性,(class和stlye和props接收的属性)都不会在$attrs中存在
  $listeners:父级组件向子级组件中传递的所有的事件,(.native修饰符的原生事件)除外,
  v-bind:可以绑定对象的形式
  v-on:可以绑定对象的形式

5. $children 和 $parent 实现组件通信
$children:可以获取当前的父级组件中的直接子级组件(间接的父子关系的组件是不行的)
$parent:可以获取当前组件的直接父级组件,要有才可以

6. 作用域插槽:可以实现父子,子父组件传递数据,组件通信
```



## 源码（数据代理，数据劫持，模板解析，双向绑定）









## vue-loader是什么

vue-loader是一个webpack的loader；可以将vue文件转换为JS模块；



## 指令（V-）

##### v-bind 强制数据绑定,强制数据绑定的指令,可以用来为某个属性动态的绑定数据

```
<!--强制数据绑定的这个指令的简写方式:     :属性名字="表达式"--><p :text="tt">这是一个p标签</p>
```

##### v-on 绑定事件监听,有时候后面不一定是回调函数，也有可能是表达式

```
<!--绑定事件监听的简写方式:  @事件名字="回调函数"  -->
<button @click="showMsg4">一个小故事</button>
```

##### v-model 双向数据绑定,一般用在表单标签中,   相当于:value和input事件的配合

```
<!--双向数据绑定指令,v-model="表达式",一般用在表单标签中-->
<input type="text" v-model="msg" />
<p>{{msg}}</p>
```

##### v-if

v-if和v-else通常都是配合使用,

v-if可以单独使用

使用了v-if指令或者v-else指令的标签,如果为true,则该标签在DOM树存在,如果表达式的值是false,当前的这个标签在DOM树是不存在的

```
<p v-if="isSeen">我喜欢你</p>
<p v-else>你喜欢我</p>
```

##### v-show

v-show指令,可以设置标签的显示和隐藏,几乎和v-if类似,但是,区别在于使用v-show指令的标签,无论是显示还是隐藏,在DOM树中始终存在,v-if(v-else,v-else-if)指令的标签,有可能在DOM树中不存在

另外使用v-show指令的标签主要是通过style属性中的display属性来控制其显示或者隐藏

```
<!--方式2:使用v-show指令实现--><button @click="isShow=!isShow">切换显示效果</button><p v-show="isShow">我想你啊</p>
```

##### v-for:遍历数据的指令

```
v-for指令:
      语法1:
       v-for="(表达式1,表达式2) in 数组"
       表达式1---->数组中每一个项--->数组元素
       表达式2---->数组中的索引
      语法2:
       v-for="表达式 in 数组"
       表达式---->数组中每一个项----数组元素

      语法3:
       v-for="(表达式1,表达式2,表达式3) in 对象"
       表达式1--->值
       表达式2--->键
       表达式3--->索引
```

##### v-text和v-html

v-text和v-html起了插值表达式{{}}作用

```
<p v-text="content">{{content}}</p>
<a v-html="content">百度</a>
```

text获取不会带标签，也解析不了标签

html获取带标签，设置可以解析标签



##### v-slot 插槽

普通插槽，具名插槽，作用域插槽



**注意：v-if和v-for最好不要同时使用，在一起使用时v-for比v-if优先级高**

## 生命周期/钩子函数

可以理解vue生命周期就是指vue实例从创建到销毁的过程，在vue中分为8个阶段：**创建前/后，载入前/后，更新前/后，销毁前/后。**

## 一、创建（实例）

1、**beforeCreate（ 数据初始化之前**）：这个阶段实例已经初始化，只是数据观察与事件机制尚未形成，不能获取DOM节点（没有data，没有el）
使用场景：因为此时data和methods都拿不到，所以通常在实例以外使用
2、**created（ 数据初始化之后）**：**实例已经创建，仍然不能获取DOM节点（有data，没有el）**
使用场景：模板渲染成html前调用，此时可以获取data和methods，so 可以初始化某些属性值，然后再渲染成视图，异步操作可以放在这里

## 二、载入（数据）

1、**beforeMount（界面显示之前)**：是个过渡阶段，此时依然获取不到具体的DOM节点，但是vue挂载的根节点已经创建（有data，有el）
2、**mounted(界面渲染后)**：**数据和DOM都已经被渲染出来了**
使用场景：模板渲染成html后调用，通常是初始化页面完成后再对数据和DOM做一些操作，需要操作DOM的方法可以放在这里

## 三、更新

1、**beforeUpdate（界面更新前）**：检测到数据更新时，但在DOM更新前执行
2、**updated（界面更新后）**：更新结束后执行
使用场景：需要对数据更新做统一处理的；如果需要区分不同的数据更新操作可以使用$nextTick

## 四、销毁

1、**beforeDestroy（组件销毁前）**：当要销毁vue实例时，在销毁前执行
2、**destroyed（组件销毁后）**：销毁vue实例时执行



### 面试题

#### 1、什么是 vue 生命周期？有什么作用？

答：每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做 生命周期钩子 的函数，这给了用户在不同阶段添加自己的代码的机会。（ps：生命周期钩子就是生命周期函数）例如，如果要通过某些插件操作DOM节点，如想在页面渲染完后弹出广告窗， 那我们最早可在mounted 中进行。

#### 2、created和mounted的区别

- created一般是在html渲染前的操作，此时el还是undefined，data已经存在。这里不能对dom进行操作。
- mounted一般是在html渲染完成后的操作，此时el，data都已经加载完成，一般对dom的操作都写在mounted中，例如获取innerHTML，初始化echarts的时候。

#### 3、第一次页面加载会触发哪几个钩子？

答：beforeCreate， created， beforeMount， mounted

#### 4、简述每个周期具体适合哪些场景

答：

- beforeCreate：在new一个vue实例后，只有一些默认的生命周期钩子和默认事件，其他的东西都还没创建。在beforeCreate生命周期执行的时候，data和methods中的数据都还没有初始化。不能在这个阶段使用data中的数据和methods中的方法
- create：data 和 methods都已经被初始化好了，**如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作**
- beforeMount：执行到这个钩子的时候，在内存中已经编译好了模板了，但是还没有挂载到页面中，此时，页面还是旧的
- mounted：执行到这个钩子的时候，就表示Vue实例已经初始化完成了。此时组件脱离了创建阶段，进入到了运行阶段。 如果我们想要通过插件操作页面上的DOM节点，最早可以在和这个阶段中进行
- beforeUpdate： 当执行这个钩子时，页面中的显示的数据还是旧的，data中的数据是更新后的， 页面还没有和最新的数据保持同步
- updated：页面显示的数据和data中的数据已经保持同步了，都是最新的
- beforeDestory：Vue实例从运行阶段进入到了销毁阶段，这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于可用状态。还没有真正被销毁
- destroyed： 这个时候上所有的 data 和 methods ， 指令， 过滤器 ……都是处于不可用状态。组件已经被销毁了。

#### 5、vue获取数据在哪个周期函数

答：一般 created/beforeMount/mounted 皆可。
比如如果你要操作 DOM , 那肯定 mounted 时候才能操作。





# React

#### React是什么

**React是用于构建用户界面的JavaScript框架。**

#### React的优点

##### 1、React速度很快

它并不直接对DOM进行操作，引入了一个叫做`虚拟DOM`的概念，安插在javascript逻辑和实际的DOM之间，性能好

##### 2、跨浏览器兼容

虚拟DOM帮助我们解决了跨浏览器问题，它为我们提供了标准化的API，甚至在IE8中都是没问题的。

##### 3、一切都是component：

代码更加`模块化`，重用代码更容易，可维护性高。

##### 4、单向数据流

单向数据流，灵活、可预计、可控制  

##### 5、同构、纯粹的javascript

因为搜索引擎的爬虫程序依赖的是服务端响应而不是JavaScript的执行，预渲染你的应用`有助于搜索引擎优化`。

##### 6、兼容性好

比如使用RequireJS来加载和打包，而Browserify和Webpack适用于构建大型应用。它们使得那些艰难的任务不再让人望而生畏

##### 虚拟DOM为什么很快

react的虚拟DOM，是一个存储于内存中的JavaScript对象，react先将页面发生的变化更新到虚拟DOM，每一次的变化都和上一次虚拟DOM的状态进行比较，找到变化的部分，最终raect会将包含了所有变化的虚拟DOM与真实DOM进行比较，找到DOM发生变化的部分，一次性应用到DOM上，从而提高页面渲染速度与性能。

**总结：虚拟dom加diff算法减少不必要的dom操作来提高渲染性能**

避免直接频繁地操作DOM，只需要在js对象模拟的虚拟DOM进行比对，再将更改的部分应用到真实的DOM树上

#### React的缺点：

并不是一个完整的框架，基本都需要加上ReactRouter和Flux才能写大型应用



## 路由router（跳转以及传参）

npm install react-router-dom下载

### react-router的理解

1)    	react的一个插件库

2)         专门用来实现一个SPA应用

3)         基于react的项目基本都会用到此库

### 什么是路由

a.     一个路由就是一个映射关系(key:value)

b.     key为路由路径, value可能是function/component





### React里面将路由的功能全都封装成了组件（API）

1)     <BrowserRouter>

2)     <HashRouter>

3)     <Route> 类似于router-view(视图显示)，有几个组件就写几个

```js
<Route path="/home/news" component={News}></Route>
// 是不是这个地址，然后加载对应的组件显示
// exact是Route下的一个属性，react路由会匹配到所有能匹配到的路由组件，exact能够使得路由的匹配更严格一些。
//'/'根路径能匹配所有的路径，所以要加exact属性严格匹配
```

4)     <Redirect>

```js
<Redirect to="/home/news" />
// 重定向 能匹配所有路径,一般写在Route后面，写在前面的话后面的Route就不会显示了，前面的Route地址都匹配不到的话，就匹配Redirect地址
```

5)     <Link> 

```js
<Link to="/home/news">News</Link>
// 就是router-link，编程式路由跳转，不带样式，点击浏览器路径会变
// 也有exact属性
```

6)     <NavLink>

```js
<NavLink to="/home/news">News</NavLink>
// 就是router-link，编程式路由跳转，带选中样式
// 也有exact属性
```

7)     <Switch>

```js
<Switch>
  <Route path="/home/news" component={News}></Route>
  <Route path="/home/message" component={Message}></Route>
  <Redirect to="/home/news" />
</Switch>

//  Switch 切换路由组件显示：只让其中一个路由组件生效,两个地址一样的话，默认第一个生效
```

**react-router-dom库向外暴露n个组件**

  **BrowserRouter history模式**

  **HashRouter  hash模式(地址带#)**

   **要求：所有路由组件都必须是他们的子组件（必须是嵌套关系）**



### 路由的跳转方式

1. **路由链接导航(声明式)**

​    **Link NavLink**

```js
 <Link to={`/home/message/${mes.id}`}>{mes.content}</Link>
 <Route path="/home/message/:id" component={MessageDetail} />
 // :id 路径定义占位符
```



2. **编程式导航（编程式路由跳转）**

​    **history.push/replace/goBack/goForward**

```js
<button onClick={this.push(path)}>push</button>
<button onClick={this.replace(path)}>replace</button>
```

**什么时候用哪种？**

   **如果只要去做跳转行为，就用路由链接导航**

   **如果除了跳转行为，还需要干一些其他事（发送请求、保存数据等），就用编程式导航**





### 路由传参

**1、params传递参数** 

​       **\- 路径定义占位符**

```js
 Link方式：
<Link to={`/home/message/${id}`}>{mes.content}</Link>
 <Route path="/home/message/:id" component={MessageDetail} />
 // :id 路径定义占位符
Js方式：
 this.props.history.push(`/home/message/${id}`)
```

​       **\- 使用   MessageDetail  组件通过 this.props.match.params 获取传递的参数ID**

​      



 **2、query传递参数(用的少)**

 注：不需要配置路由表。路由表中的内容照常：<Route path='/sort' component={Sort}></Route>

 **1.Link处**    

​    **HTML方式**

​      **<Link to={{ path : ' /sort ' , query : { name : 'sunny' }}}>**　　　　　　　　

​    **JS方式**

​      **this.props.history.push({ path : '/sort' ,query : { name: ' sunny'} })**

 **2.sort页面**   

​       **this.props.location.query.name**

​       **输入地址 、 更新地址 http://localhost:3000/home/message/1?name=jack**

```js
<button onClick={this.push(`/home/message/${id}?name=jack`)}>push</button>
//params和query可以并存
```

​       **\- 使用 组件通过 this.props.location.search获取传递的参数，但是不是一个对象，未处理的需要自己处理好**

​       

3. **state传递参数**

​       **\- 传递参数** （参数加密，不在地址栏显示）

```js
<button onClick={this.push(path)}>push</button>
push = (path) => {
  return () => {
    this.props.history.push(path, { name: "huahua", age: 48 });
  };
};
// push方法第一个参数为path(to)地址，第二个参数为需要传递的参数
```

​       **\- 使用 组件通过 this.props.location.state 获取传递的参数**

​     **通过state**

​       **同query差不多，只是属性不一样，而且state传的参数是加密的，query传的参数是公开的，在地址栏**

​     **1.Link 处**    

​      **HTML方式：**

​        **<Link to={{ pathname : ' /user' , state : { day: 'Friday' }}}>** 　

​     **JS方式：**

​      **this.props.history.push({ pathname:'/user',state:{ day : 'Friday' } })**

​     **2. user页面**     

​      **this.props.location.state.day**



**凡是通过Route加载的组件，就成为路由组件，组件内部能接受到三个属性**

​       **history 路由跳转**

​       **location 获取query和state参数，以及当前路由路径**

​       **match 获取params参数**



## Redux

### redux是什么?

**使用下载 npm install  redux**

1)     redux是一个独立专门用于做状态管理的JS库(不是react插件库)

2)     它可以用在react, angular, vue等项目中, 但基本与react配合使用

3)     作用: 集中式管理react应用中多个组件共享的状态

### 什么情况下需要使用redux

1)     总体原则: 大型项目状态管理复杂才用

2)         某个组件的状态，需要共享

3)         某个状态需要在任何地方都可以拿到

4)         一个组件需要改变全局状态

5)         一个组件需要改变另一个组件的状态

### redux的三大原则

单一数据源

state是只读的（不能在state上面直接修改数据，改变state的唯一方法是触发action）

使用纯函数执行修改（一个函数的返回结果只依赖其参数，并且执行过程中没有副作用）

### redux的三个核心概念

**action：用来创建action对象的工厂函数模块，要定义多少个action函数，要看对数据有多少种操作**

**reducer：Reducer 是一个函数，它接受Action和当前的state作为参数，返回一个新的state。为了获取状态数据，一开始会自动调用一次**

**store：用来集中存储数据的仓库**

- redux中的store是通过createStore方法创建的，该方法接收两个参数**reducer函数**和**初始化的数据(currentState)**，从而形成一颗状态树

- createStore方法调用时传入的reducer方法会在store的dispatch被调用的时候，被调用，接收store中的state和action，根据业务逻辑（即reducer方法）返回新的state
- **store含有四个方法，`subscribe`、`dispatch`、`getState`和`replaceReducer`**
  1. `subscribe`:接收一个回调(listener)，当dispatch触发时，执行reducer函数去修改当前数据(currentState)，并执行subscribe传入的回调函数(listener)**（监听数据变化）**
  2. `dispatch`:分发 action。这是触发 state 变化的惟一途径**（触发更新）**
  3. `getState`:**读取所有数据**
  4. `replaceReducer`:替换 store 当前用来计算 state 的 reducer,不常用

### react-redux

### 是什么

1)     一个react插件库

2)     专门用来简化react应用中使用redux

###  使用react-redux

**npm install --save react-redux**

### 相关API

**1)     Provider**

**让所有组件都可以得到state数据**

![image-20201023205013401](C:\Users\宋文现\AppData\Roaming\Typora\typora-user-images\image-20201023205013401.png)

**2)     connect()**    组件之外书写 **可以在当前的组件得到状态数据以及改变状态数据的方法**（action里的函数）

**connect 高阶组件（HOC）：本质上是一个函数，执行函数传入一个组件作为参数，返回值是一个新组件**

**作用：主要是用来复用代码**

```js
import { connect } from "react-redux";
import { increment, decrement } from "./redux/actions";
// 参数1为状态数据 ，参数2为改变状态数据的方法
export default connect((state) => ({ xxx: state.xxx }), {
  // 这两个是引入的action里的函数
  // 内部也进行了mapDispatchToProps()的方式处理过
  // 作用有生成action对象并且触发reducer函数
  increment,
  decrement,
})(App);

// 将count和increment，decrement都作为属性以props的方式传给了App组件,直接this.props.xxx使用
```



### Redux工作流程图

![](D:\笔记案例\熊健 React教学\redux工作流程图.png)



## 组件通信

1 prop 父——————》子(this.props.xxx)

2 pubsub  任意

3 自定义事件    子——————》父(this,props.xxx触发)

4 redux 任意

5 context

在 react 中没有类似 vue 中的事件总线来解决这个问题，我们只能借助它们共同的父级组件来实现，将非父子关系装换成多维度的父子关系。

react 中数据是通过 props 属性自上而下（由父及子）进行传递的，但这种做法对于多层级父子关系的组件传值是极其繁琐的。react 提供了`context` api 来实现在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。React 16.3之后的`context`api 较之前的好用。



## 三大属性

### 组件的 state 用法

1)     state是组件对象最重要的属性, 值是对象(可以包含多个数据)

2)     组件被称为"状态机", 通过更新组件的state来更新对应的页面显示(重新渲染组件)

那个组件需要state数据展示，state就写在哪个组件里，判断需不需要state？界面更新渲染了就需要state

### 组件的 props 用法

　**1，理解：**

　　　　1) 每个组件对象都会有 props 属性

　　　　2）组件标签中所以的属性都保存在 props 中

　　**2，作用：**

　　　1）通过标签属性从组件外向组件内传递变化的数据

　　　  2）组件内部不需要修改 props 数据



### 组件的 ref 用法

1）组件内的标签都可以定义 ref 属性来标识自己

2）作用：通过 ref 获取组件特定的标签对象，进行读取相关数据

## 受控组件与非受控组件

受控组件是通过state+onChange事件来收集数据的，相当于手动去实现vue中的 v-model，非受控组件是通过ref技术来获取dom，操作原生的api获取数据，收集  表单数据时一般都推荐使用受控组件的方式

## HookS

Hook是React16.8推出的一门技术，hook本质就是让我们使用无状态函数组件  的情况下可以使用state以及其他react的特性，常见的hook有useState、  useEffect、自定义hook，

useState是用来定义状态的，它提供一个状态和更新  状态的数据方法，状态的初始值就是useState传的参数，

useEffect是用来模拟   类组件中的生命周期的。如果不传递第二个参数，相当于componentDidMount 和componentDidUpdate，如果第二个参数传递的是一个空数组，相当于  componentDidMount，如果传递的是一个指定的状态值，那么就是在这个状态值 发生改变的时候才会执行函数，如果内部在return一个函数，那在这个return函   数内部就相当于componentDidUnmount







## 生命周期

**在初始化时会触发5个钩子函数(初始化会触发render,更新也会触发render)**

1、getDefaultProps() 忽略

> 设置默认的props，也可以用dufaultProps设置组件的默认属性。

2、getInitialState() 忽略

> 在使用es6的class语法时是没有这个钩子函数的，可以直接在constructor中定义this.state。此时可以访问this.props。

3、componentWillMount()被取代

> 组件初始化时只调用，以后组件更新不调用，整个生命周期只调用一次，此时可以修改state。

4、 render()

> react最重要的步骤，创建虚拟dom，进行diff算法，更新dom树都在此进行。此时就不能更改state了。

**5、componentDidMount() 重要 发送Ajax请求、绑定事件、设置定时器等一次性任务**

> 组件渲染之后调用，可以通过this.getDOMNode()获取和操作dom节点，只调用一次。

**在更新时也会触发5个钩子函数：**

6、componentWillReceivePorps(nextProps)被取代

> 组件初始化时不调用，组件接受新的props时调用。

7、**shouldComponentUpdate(nextProps, nextState)**

> react性能优化非常重要的一环。组件接受新的state或者props时调用，我们可以设置在此对比前后两个props和state是否相同，如果相同则返回false阻止更新，因为相同的属性状态一定会生成相同的dom树，这样就不需要创造新的dom树和旧的dom树进行diff算法对比，节省大量性能，尤其是在dom结构复杂的时候。不过调用this.forceUpdate会跳过此步骤。
>
> 决定组件要不要更新？看数据（state，props）是否发生变化， 只要state，props有一个发生变化，就要更新

8、componentWillUpdate(nextProps, nextState)

> 组件初始化时不调用，只有在组件将要更新时才调用，此时可以修改state

9、render()

> 不多说

10、componentDidUpdate()

> 组件初始化时不调用，组件更新完成后调用，此时可以获取dom节点。

还有一个卸载钩子函数

**11、componentWillUnmount() 重要，做一些收尾工作，如清理定时器**

> 组件将要卸载时调用，一些事件监听和定时器需要在此时清除。

以上可以看出来react总共有10个周期函数（render重复一次），这个10个函数可以满足我们所有对组件操作的需求，利用的好可以提高开发效率和组件性能。

**12、static getDerivedStateFromProps()重要，**

> 这个生命周期函数用来取代 UNSAFE_componentWillMount  UNSAFE_componentWillReceiveProps，所以 UNSAFE_componentWillMount 不会生效

### unmountComponentAtNode（需要引入react-dom）

unmountComponentAtNode用于执行卸载组件的操作，执行在componentWillUnmount之前。

```js
goDie = () => {
  // 卸载组件的操作
  ReactDOM.unmountComponentAtNode(document.getElementById("root"));
};
j
<button onClick={this.goDie}>不活了</button>
```









## 高阶组件

高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术

hoc本质上是一个函数，接受一个组件作为参数，返回一个新组件，新组件    内部套着旧组件，实现代码和逻辑的复用

在我们项目中使用react-redux框架的时候，有一个`connect`的概念，这里的`connect`其实就是一个高阶组件





## 总结：React和vue的区别

相同点： 

都支持服务端渲染

都有Virtual（虚拟） DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范

数据驱动视图(数据变化了重新渲染界面)

都有支持native的方案，React的React native，Vue的weex

- **都是单向数据流**

数据流指的是组件之间的数据流动。（通过props父组件向子组件传递数据，react父组件变化了，全部子组件都会重新渲染）

虽然vue有双向绑定v-model，但是vue和react父子组件之间数据传递，仍然还是遵循单向数据流的，父组件可以向子组件传递props，但是子组件不能修改父组件传递来的props，子组件只能通过事件通知父组件进行数据更改。

单向数据流的好处是更容易追踪数据变化排查问题，利于应用的可维护性。





不同点：

React严格上只针对MVC的view层，Vue则是MVVM模式

virtual（虚拟） DOM 不一样 vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过shouldComponentUpdate这个生命周期方法来进态行控制，

组件写法不一样 React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即”all in js” Vue 推荐的是使用 webpack + vue-loader 的单文件组件格式，即html,css,js写在同一个文件；

数据绑定：Vue有实现了双向数据绑定，React数据流动是单向的

state对象在react应用中是不可变的，需要使用setState方法更新状；在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理。



Virtual DOM是一个映射真实DOM的JavaScript对象，如果页面发生了变化，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。





# 方法总结	

**伪数组转真数组**

```js
Array.from(divObjs)

[...divObjs]

Array.prototype.slice.call(divObjs)

[].slice.call(divObjs)
```



## 判断对象是不是一个数组

**1、从原型入手，Array.prototype.isPrototypeOf(obj);**

**2、也可以从构造函数入手，obj instanceof Array**

**3、根据对象的class属性(类属性)，跨原型链调用toString()方法。**

**4、Array.isArray()方法。**



## 判断一个对象是不是函数

```
function isFun(obj) {
    retrun Object.prototype.toString.call(obj) === '[object Function]';
}
```

## 判断一个变量是不是null

```
Object.prototype.toString.call(null)==='[object Null]'
```





















**11.iframe的优缺点？**

答案：iframe也称作嵌入式框架，嵌入式框架和框架网页类似，它可以把一个网页的框架和内容嵌入在现有的网页中。
**优点：**

- 解决加载缓慢的第三方内容如图标和广告等的加载问题
- Security sandbox
- 并行加载脚本
- 方便制作导航栏

**缺点：**

- iframe会阻塞主页面的Onload事件
- 即使内容为空，加载也需要时间
- 没有语意